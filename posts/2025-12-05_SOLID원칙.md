# SOLID원칙

**작성일**: Fri, 5 Dec 2025 17:28:57 +0900

**원문 링크**: https://junsseok.tistory.com/52

---

<p style="text-align: center;">SOLID 원칙</p>
<hr contenteditable="false" />
<p style="text-align: center;">객체지향 설계의 5가지 핵심 원칙으로, 유지보수성과 확장성을 높이기 위해 사용된다</p>
<hr contenteditable="false" />
<p style="text-align: left;">&nbsp;</p>
<h3>1. SRP(Single Responsibility Principle)</h3>
<p>&nbsp;</p>
<p><b>클래스는 오직 하나의 이유로만 변경돼야 한다는 원칙</b></p>
<p>&nbsp;</p>
<p>- 하나의 클래스를 여러 기능이 섞인 만능 클래스로 만들지 말라는 것</p>
<p>-&nbsp;변경의&nbsp;이유가&nbsp;여러&nbsp;개면&nbsp;유지보수&nbsp;비용이&nbsp;커진다</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>나쁜 예 :</b></p>
<pre class="bash" id="code_1764922947236"><code>class UserService {
    void createUser() {}
    void sendEmail() {}
    void saveToDatabase() {}
}</code></pre>
<p>&nbsp;</p>
<p><b>좋은 예 :&nbsp;</b></p>
<pre class="bash" id="code_1764922960364"><code>class UserService { void createUser() {} }
class EmailService { void sendEmail() {} }
class UserRepository { void save() {} }</code></pre>
<hr contenteditable="false" />
<h3 style="color: #000000; text-align: start;">2. OCP(Open / Closed Principle)</h3>
<p>&nbsp;</p>
<p><b>확장엔 열려 있고</b>, <b>수정엔 닫혀 있어야 한다는 원칙</b></p>
<p>&nbsp;</p>
<p>-&nbsp;새로운&nbsp;기능을&nbsp;추가할&nbsp;때&nbsp;기존&nbsp;코드를&nbsp;수정하지&nbsp;않고&nbsp;확장해서&nbsp;해결해야&nbsp;한다 <br />-&nbsp;변경에&nbsp;강한&nbsp;구조를&nbsp;만드는&nbsp;원칙</p>
<p>&nbsp;</p>
<p><b>나쁜 예 : (책임이 너무 많다) </b></p>
<pre class="bash" id="code_1764922996948"><code>class PaymentService {
    void pay(String type) {
        if (type.equals("card")) { ... }
        else if (type.equals("bank")) { ... }
    }
}</code></pre>
<p>&nbsp;</p>
<p><b>좋은 예 : (기능 분리) </b></p>
<pre class="bash" id="code_1764923004172"><code>interface Payment { void pay(); }

class CardPayment implements Payment { ... }
class BankPayment implements Payment { ... }

class PaymentService {
    void process(Payment payment) {
        payment.pay();
    }
}</code></pre>
<hr contenteditable="false" />
<h3 style="color: #000000; text-align: start;">3. LSP(Liskov Substitution Principle )</h3>
<p>&nbsp;</p>
<p><b>부모 타입을 사용하는 곳에서는 자식 타입을 문제 없이 사용할 수 있어야 한다는 원칙</b></p>
<p>&nbsp;</p>
<p>- 부모-자식 관계를 만들었다면 자식이 부모의 행위를 망가뜨리면 안 된다는 것</p>
<p>&nbsp;</p>
<p><b>나쁜 예 : (부모(Rectangle)가 예상한 동작을 자식(Square)이 깨버림 ) </b></p>
<pre class="bash" id="code_1764923280700"><code>class Rectangle { void setWidth(int w){} }
class Square extends Rectangle { void setWidth(int w){ /* 강제로 height도 변경 */ } }</code></pre>
<p>&nbsp;</p>
<p><b>좋은 예 : (상속 대신 인터페이스로 분리해서 서로의 동작을 방해하지 않음)</b></p>
<pre class="bash" id="code_1764923287539"><code>interface Shape { int getArea(); }
class Rectangle implements Shape { ... }
class Square implements Shape { ... }</code></pre>
<hr contenteditable="false" />
<h3 style="color: #000000; text-align: start;">4. ISP(Interface Segregation Principle)</h3>
<p>&nbsp;</p>
<p><b>범용 인터페이스 하나보다, 구체적 인터페이스 여러 개가 더 낫다</b></p>
<p>&nbsp;</p>
<p>- 필요 없는 메서드까지 강제로 구현하게 되는 것을 막기 위함</p>
<p>&nbsp;</p>
<p><b>관리 로봇</b></p>
<p style="color: #333333; text-align: start;"><b>나쁜 예 : (관리 로봇은 eat() 이 필요 없음)</b></p>
<pre id="code_1764923116812" style="background-color: #f8f8f8; color: #383a42;"><code>interface Worker {
    void work();
    void eat();
}</code></pre>
<p style="color: #333333; text-align: start;">&nbsp;</p>
<p style="color: #333333; text-align: start;"><b>좋은 예 :</b></p>
<pre id="code_1764923116812" style="background-color: #f8f8f8; color: #383a42;"><code>interface Workable { void work(); }
interface Eatable { void eat(); }</code></pre>
<p>&nbsp;</p>
<hr contenteditable="false" />
<h3 style="color: #000000; text-align: start;">5. DIP(Dependency Inversion Principle)</h3>
<p>&nbsp;</p>
<p><b> 상위 모듈(비즈니스 로직)은 하위 모듈(구현)에 의존하면 안 된다.</b></p>
<p>&nbsp;</p>
<p>- 둘 다 추상화에 의존해야 한다</p>
<p>- 구체 클래스가 아니라 인터페이스(추상화) 에 의존해라</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>나쁜 예 : (구현에 쉽게 의존)</b></p>
<pre class="bash" id="code_1764923126332"><code>class NotificationService {
    EmailSender emailSender = new EmailSender();
}</code></pre>
<p>&nbsp;</p>
<p><b>좋은 예 : (구현에 의존 X)</b></p>
<pre class="bash" id="code_1764923132316"><code>interface Sender { void send(); }

class EmailSender implements Sender { ... }

class NotificationService {
    private Sender sender;

    NotificationService(Sender sender) {
        this.sender = sender;
    }
}</code></pre>
<hr contenteditable="false" />
<h3 style="color: #000000; text-align: left;">S: 클래스는 하나의 책임만<br />O: 기능은 수정 말고 확장으로<br />L: 자식은 부모를 자연스럽게 대체<br />I: 큰 인터페이스 쪼개서 필요만 주자<br />D:&nbsp;구체가&nbsp;아니라&nbsp;인터페이스에&nbsp;의존</h3>
<hr contenteditable="false" />
<h3 style="text-align: center;">면접한줄요약</h3>
<p>&nbsp;</p>
<p style="text-align: center;"><b>SOLID&nbsp;원칙은&nbsp;코드의&nbsp;변경&nbsp;비용을&nbsp;줄이고,&nbsp;유지보수성과&nbsp;확장성을&nbsp;높이기&nbsp;위해&nbsp;적용한다.</b></p>