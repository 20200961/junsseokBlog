# Day8

**카테고리**: 수강 일지

**작성일**: Mon, 4 Aug 2025 17:26:55 +0900

**원문 링크**: https://junsseok.tistory.com/7

---

<p>SQL FINAL</p>
<p><figure class="imageblock alignCenter"><span><img height="225" src="https://blog.kakaocdn.net/dn/cgOTXL/btsPB03Ki4X/E0kyvQUyEiiCSf0PbeIaHK/img.png" width="225" /></span></figure>
</p>
<p><br /><br /></p>
<p>&lt;PL/SQL&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;오라클&nbsp;DBMS에서&nbsp;사용하는&nbsp;절차적&nbsp;SQL&nbsp;확장&nbsp;언어다. <br />&nbsp;&nbsp;&nbsp;&nbsp;일반&nbsp;SQL의&nbsp;단점을&nbsp;보완해서&nbsp;변수의&nbsp;정의,&nbsp;조건(IF),&nbsp;반복(FOR,WHILE)&nbsp;등을&nbsp;지원하여&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;다수의&nbsp;SQL문을&nbsp;한번에&nbsp;실행할&nbsp;수&nbsp;있다. <br />&nbsp;&nbsp;&nbsp;&nbsp;PL/SQL은&nbsp;블록구조를&nbsp;사용함.</p>
<p>&nbsp;</p>
<p>PL/SQL&nbsp;구조 <br />&nbsp;&nbsp;&nbsp;&nbsp;DECLARE&nbsp;&nbsp;&nbsp;--&nbsp;(선택)선언부&nbsp;:&nbsp;변수,&nbsp;상수등을&nbsp;선언 <br />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;실행부&nbsp;:&nbsp;SQL문&nbsp;또는&nbsp;제어문&nbsp;등의&nbsp;로직을&nbsp;기술 <br />&nbsp;&nbsp;&nbsp;&nbsp;EXCEPTION&nbsp;--&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;END;&nbsp;</p>
<p>&nbsp;</p>
<p>예)</p>
<pre class="bash" id="code_1754295504631"><code>BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO ORACLE');
END;</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>1.&nbsp;DECLARE&nbsp;선언부 <br />&nbsp;&nbsp;&nbsp;&nbsp;변수&nbsp;및&nbsp;상수를&nbsp;선언하는&nbsp;공간 <br />&nbsp;&nbsp;&nbsp;&nbsp;일반타입변수,&nbsp;레퍼런스&nbsp;타입변수,&nbsp;ROW&nbsp;타입&nbsp;변수 <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />(1) 일반 타입 변수 선언 및 초기화 <br />&nbsp;&nbsp;&nbsp;&nbsp;DECLARE <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;변수명[CONSTANT]&nbsp;자료형&nbsp;[:=&nbsp;초기값]</p>
<pre class="bash" id="code_1754295524550"><code>DECLARE
    EID NUMBER;
    ENAME VARCHAR2(20);
    PI CONSTANT NUMBER := 3.14;
BEGIN
    EID := 800;
    ENAME := '최지원';
    
    DBMS_OUTPUT.PUT_LINE('EID : ' || EID);
    DBMS_OUTPUT.PUT_LINE('ENAME : ' || ENAME);
    DBMS_OUTPUT.PUT_LINE('PI : ' || PI);
END;
/</code></pre>
<p>&nbsp;</p>
<p>(2) 래퍼런스 타입 변수 : 어떤 테이블의 어떤 컬럼의 데이터타입을 참조해서 사용할지를 정하는 방식</p>
<pre class="bash" id="code_1754295562023"><code>DECLARE
    EID EMPLOYEE.EMP_ID%TYPE;
    ENAME EMPLOYEE.EMP_NAME%TYPE;
    SAL EMPLOYEE.SALARY%TYPE;
BEGIN
--    EID := 800;
--    ENAME := '최지원';
--    SAL := 1000000;
    
    SELECT EMP_ID,EMP_NAME,SALARY
    INTO EID,ENAME,SAL
    FROM EMPLOYEE
    WHERE EMP_ID = &amp;사번;
    
    DBMS_OUTPUT.PUT_LINE('EID : ' || EID);
    DBMS_OUTPUT.PUT_LINE('ENAME : ' || ENAME);
    DBMS_OUTPUT.PUT_LINE('SAL : ' || SAL);
END;
/</code></pre>
<p>&nbsp;</p>
<p>래퍼런스타입&nbsp;변수로&nbsp;EID,&nbsp;ENAME,&nbsp;SAL,&nbsp;DTITLE을&nbsp;선언하고 <br />각 자료형 EMPLOYEE(EMP_ID,EMP_NAME,JOB_CODE,SALARY), DEPARTMENT(DEPT_TITLE)을 <br />참조하고 사용자가 입력한 사번의 사번,사원명,직급코드,급여,부서명 조회 후 각 변수에 담에서 출력</p>
<pre class="bash" id="code_1754295584999"><code>SELECT * FROM EMPLOYEE;
DECLARE 
    EMPID   EMPLOYEE.EMP_ID%TYPE;
    ENAME   EMPLOYEE.EMP_NAME%TYPE;
    JCODE   EMPLOYEE.JOB_CODE%TYPE;
    SAL     EMPLOYEE.SALARY%TYPE;
    DTITLE  DEPARTMENT.DEPT_TITLE%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY, DEPT_TITLE
    INTO EMPID, ENAME, JCODE, SAL, DTITLE
    FROM EMPLOYEE
    JOIN DEPARTMENT ON (EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID)
    WHERE EMP_ID = &amp;사번;
    
    DBMS_OUTPUT.PUT_LINE(EMPID || ', ' || ENAME || ', ' || JCODE || ', ' || SAL || ', ' || DTITLE);
END;
/</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>(3) ROW타입 변수 선언 <br />테이블의 한 행에 대한 모든 컬럼값을 한번에 담을 수 있는 변수 <br />변수명 테이블명%ROWTYPE</p>
<pre class="bash" id="code_1754295608399"><code>DECLARE
    E EMPLOYEE%ROWTYPE;
BEGIN

    SELECT *
    INTO E
    FROM EMPLOYEE
    WHERE EMP_ID =&amp;사번;
    
    DBMS_OUTPUT.PUT_LINE(E.EMP_ID || ', ' || E.EMP_NAME || ', ' || E.BONUS);
END;
/</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2. BEGIN 실행부</p>
<pre class="bash" id="code_1754295633374"><code>&lt;조건문&gt;
    1) 단일 IF(IF를 단독으로 사용할 때)
    IF 조건식 THEN 
        실행내용
    END IF;</code></pre>
<p>&nbsp;</p>
<p>3. 조건문</p>
<pre class="bash" id="code_1754295682759"><code>IF-ELSE 조건식
    
    IF 조건식
        THEN 실행내용
    ELSE
        실행내용
    END IF;</code></pre>
<p>&nbsp;</p>
<p>4. 반복문&nbsp;</p>
<p>BASIC LOOP문</p>
<pre class="bash" id="code_1754295762070"><code>LOOP
      반복하고 싶은 실행문
      *EXIT WHEN 탈출조건
END LOOP;</code></pre>
<p>*탈출조건은 조건식 <br />&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;IF&nbsp;조건식&nbsp;THEN&nbsp;EXIT;&nbsp;END&nbsp;IF; <br />&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;EXIT&nbsp;WHEN&nbsp;조건식;</p>
<p>&nbsp;</p>
<p>5. FOR LOOP문 (횟수가 정해진 반복)</p>
<pre class="bash" id="code_1754295740015"><code>FOR 변수 IN [REVERSE] 초기값... 최종값
    LOOP
        반복할 코드
    END LOOP;</code></pre>
<p>&nbsp;</p>
<p>6. WHILE LOOP문</p>
<pre class="bash" id="code_1754295774918"><code>WHILE 반복문이 수행될 조건
    LOOP
        반복할 명령어
    END LOOP;</code></pre>
<p>&nbsp;</p>
<p>7.&nbsp;예외(EXCEPTION)&nbsp;:&nbsp;실행&nbsp;중&nbsp;발생하는&nbsp;오류 <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;EXCEPTION <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN&nbsp;예외명1&nbsp;THEN&nbsp;처리구문1; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN&nbsp;예외명2&nbsp;THEN&nbsp;처리구문2; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <br />&nbsp;&nbsp;&nbsp;&nbsp;*시스템&nbsp;예외(오라클이&nbsp;미리&nbsp;설정해둔&nbsp;예외) <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;NO_DATA_FOUND&nbsp;:&nbsp;SELECT한&nbsp;결과가&nbsp;한&nbsp;행도&nbsp;없을&nbsp;때 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;TOO_MANY_ROWS&nbsp;:&nbsp;SELECT한&nbsp;결과가&nbsp;여러행일&nbsp;경우 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;ZERO_DIVIDE&nbsp;:&nbsp;0으로&nbsp;나눌경우 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;DUP_VAL_ON_INDEX&nbsp;:&nbsp;UNIQUE&nbsp;제약조건&nbsp;위배 <br />&nbsp;&nbsp;&nbsp;&nbsp;...</p>
<p>&nbsp;</p>
<p>8. 연습문제&nbsp;<br />--&nbsp;레퍼런스&nbsp;변수&nbsp;(EID,&nbsp;ENAME,&nbsp;DTITLE,&nbsp;NCODE)를&nbsp;생성하고 <br />--&nbsp;각&nbsp;테이블에서&nbsp;EMP_ID,&nbsp;EMP_NAME,&nbsp;DEPT_TITLE,&nbsp;NATIONAL_CODE를&nbsp;참조해라 <br />--&nbsp;일반타입변수&nbsp;TEAM을&nbsp;문자열타입으로&nbsp;생성하고&nbsp;사용자가&nbsp;입력한&nbsp;사원정보를&nbsp;가져와서&nbsp; <br />--&nbsp;사번,&nbsp;이름,&nbsp;부서명,&nbsp;근무국가코드&nbsp;조회&nbsp;후에&nbsp;각&nbsp;변수에&nbsp;대입 <br />--&nbsp;NCODE&nbsp;값이&nbsp;KO일&nbsp;경우&nbsp;-&gt;&nbsp;TEAM&nbsp;=&nbsp;국내팀 <br />--&nbsp;NCODE&nbsp;값이&nbsp;KO가&nbsp;아닐경우&nbsp;-&gt;&nbsp;TEAM&nbsp;=&nbsp;해외팀&nbsp;대입 <br />-- 사번, 이름, 부서명, 소속(TEAM을 출력)</p>
<pre class="bash" id="code_1754295661838"><code>DECLARE
    EID   EMPLOYEE.EMP_ID%TYPE;
    ENAME   EMPLOYEE.EMP_NAME%TYPE;
    DTITLE   DEPARTMENT.DEPT_TITLE%TYPE;
    NCODE    LOCATION.NATIONAL_CODE%TYPE;
    TEAM VARCHAR2(10);
BEGIN
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE, NATIONAL_CODE
    INTO EID,ENAME,DTITLE,NCODE
    FROM EMPLOYEE
    JOIN DEPARTMENT ON (EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID)
    JOIN LOCATION ON (DEPARTMENT.LOCATION_ID = LOCATION.LOCAL_CODE)
    WHERE EMP_ID = &amp;사번;
    
    IF NCODE = 'KO'
        THEN TEAM := '국내팀';
    ELSE TEAM := '해외팀';
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('사번 : ' || EID);
    DBMS_OUTPUT.PUT_LINE('이름 : ' || ENAME);
    DBMS_OUTPUT.PUT_LINE('부서명 : ' || DTITLE);
        DBMS_OUTPUT.PUT_LINE('소속 : ' || TEAM);

END;
/</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&lt;트리거&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;특정&nbsp;테이블에&nbsp;대해&nbsp;INSERT,&nbsp;UPDATE,&nbsp;DELETE와&nbsp;같은&nbsp;DML이벤트가&nbsp;발생했을&nbsp;때 <br />&nbsp;&nbsp;&nbsp;&nbsp;자동으로&nbsp;실행되는&nbsp;PL/SQL&nbsp;코드&nbsp;블록 <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;EX)&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;회원&nbsp;탈퇴시&nbsp;기존의&nbsp;회원테이블에&nbsp;데이터를&nbsp;DELETE하기&nbsp;전에&nbsp;항상&nbsp;탈퇴한&nbsp;회원들을&nbsp;저장하는 <br />&nbsp;&nbsp;&nbsp;&nbsp;테이블에&nbsp;INSERT&nbsp;시켜줘야한다. <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;신고횟수가&nbsp;일정&nbsp;수를&nbsp;넘었을&nbsp;때&nbsp;묵시적으로&nbsp;해당&nbsp;회원을&nbsp;블랙리스트&nbsp;목록에&nbsp;추가해야할&nbsp;때. <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;트리거&nbsp;특징 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;사용자가&nbsp;명시적으로&nbsp;실행하지&nbsp;않아도&nbsp;자동&nbsp;실행됨. <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;데이터&nbsp;무결성,&nbsp;로깅,&nbsp;자동처리&nbsp;등에&nbsp;유용 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;테이블&nbsp;단위로&nbsp;작성되며,&nbsp;트리거&nbsp;대상은&nbsp;테이블.</p>
<p>&nbsp;</p>
<p>트리거&nbsp;분류 <br />&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;시점(언제&nbsp;실행되냐?) <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;BEFORE&nbsp;TRIGGER&nbsp;:&nbsp;내가&nbsp;지정한&nbsp;테이블에&nbsp;DML&nbsp;이벤트가&nbsp;실행되기&nbsp;전에&nbsp;동작 <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;AFTER&nbsp;TRIGGER&nbsp;:&nbsp;내가&nbsp;지정한&nbsp;테이블에&nbsp;DML&nbsp;이벤트가&nbsp;실행된&nbsp;직후에&nbsp;동작 <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;*적용대상(어디에&nbsp;적용하는가?) <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;문장&nbsp;트리거&nbsp;:&nbsp;이벤트가&nbsp;발생한&nbsp;SQL문에&nbsp;대해&nbsp;딱&nbsp;한번만&nbsp;트리거&nbsp;실행(FOR&nbsp;EACH&nbsp;ROW&nbsp;없음) <br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;행&nbsp;트리거&nbsp;:&nbsp;이벤트가&nbsp;적용된&nbsp;각&nbsp;행마다&nbsp;실행(FOR&nbsp;EACH&nbsp;ROW&nbsp;필요) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:OLD&nbsp;=&nbsp;기존행&nbsp;데이터 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:NEW&nbsp;=&nbsp;새로&nbsp;들어오는&nbsp;데이터 <br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;[트리거&nbsp;생성&nbsp;표현식] <br />&nbsp; &nbsp;</p>
<pre class="bash" id="code_1754295187063"><code>CREATE [OR REPLACE] TRIGGER 트리거명
    BEFORE | AFTER INSERT | UPDATE | DELETE
    ON 테이블명
    BEGIN
        실행할 내용
    [EXCEPTION ...] -- 예외처리가능
END;
/</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>EMPLOYEE&nbsp;테이블에&nbsp;새로운&nbsp;행이&nbsp;추가될때마다&nbsp;자동으로&nbsp;'신입사원님&nbsp;안녕하세요'&nbsp;출력</p>
<pre class="bash" id="code_1754295232239"><code>CREATE OR REPLACE TRIGGER TRG_01
AFTER INSERT
ON EMPLOYEE
BEGIN
    DBMS_OUTPUT.PUT_LINE('신입사원님 안녕하세요.');
END;
/</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>입출고에&nbsp;대한&nbsp;데이터&nbsp;기록(INSERT)&nbsp;될때마다&nbsp;해당&nbsp;상품에&nbsp;대한&nbsp;재고수량을&nbsp;매번&nbsp;수정(UPDATE)</p>
<p>상품테이블(재고),&nbsp;입출고&nbsp;기록&nbsp;테이블</p>
<p>&nbsp;</p>
<p>(1) 상품에&nbsp;대한&nbsp;데이터를&nbsp;보관할&nbsp;상품&nbsp;테이블(TB_PRODUCT)</p>
<pre class="bash" id="code_1754295267743"><code>CREATE TABLE TB_PRODUCT(
    PCODE NUMBER PRIMARY KEY, -- 상품번호
    PNAME VARCHAR2(30) NOT NULL, -- 상품명
    BRAND VARCHAR2(30) NOT NULL, -- 제조사
    PRICE NUMBER,   -- 가격
    STOCK NUMBER DEFAULT 0 -- 재고
);</code></pre>
<pre class="bash" id="code_1754295280391"><code>CREATE SEQUENCE SEQ_PCODE
START WITH 200
INCREMENT BY 5;

INSERT INTO TB_PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'갤럭시S','삼성',1500000,DEFAULT);
INSERT INTO TB_PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'아이폰16','애플',1300000,DEFAULT);
INSERT INTO TB_PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'대륙폰','샤오미',9900000,DEFAULT);</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2. 상품&nbsp;입출고&nbsp;상세&nbsp;이력&nbsp;테이블&nbsp;생성(TB_PRODETAIL)</p>
<p>- 어떤 상품이 어떤 날짜에 몇개가 입/출고 되는지 기록</p>
<pre class="bash" id="code_1754295307615"><code>CREATE TABLE TB_PRODETAIL(
    DECODE NUMBER PRIMARY KEY, -- 이력번호
    PCODE NUMBER REFERENCES TB_PRODUCT, -- 상품번호
    PDATE DATE NOT NULL, -- 입출고 날짜
    AMOUNT NUMBER NOT NULL,
    STATUS CHAR(3) CHECK(STATUS IN('IN','OUT'))
);</code></pre>
<p>&nbsp;</p>
<p>- 200번&nbsp;상품이&nbsp;오늘날짜로&nbsp;10개&nbsp;입고</p>
<pre class="bash" id="code_1754295323416"><code>INSERT INTO TB_PRODETAIL
VALUES(SEQ_DECODE.NEXTVAL, 200, SYSDATE,10,'IN');</code></pre>
<p>&nbsp;</p>
<p>- 200번&nbsp;상품의&nbsp;재고수량이&nbsp;10&nbsp;증가</p>
<pre class="bash" id="code_1754295337263"><code>UPDATE TB_PRODUCT
SET STOCK = STOCK + 10
WHERE PCODE = 200;</code></pre>
<p>&nbsp;</p>
<p>- 205번&nbsp;상품이&nbsp;오늘날짜로&nbsp;20개&nbsp;입고</p>
<pre class="bash" id="code_1754295349855"><code>INSERT INTO TB_PRODETAIL
VALUES(SEQ_DECODE.NEXTVAL, 205, SYSDATE,20,'IN');</code></pre>
<p>&nbsp;</p>
<p>- 205번&nbsp;상품의&nbsp;재고수량이&nbsp;20증가</p>
<pre class="bash" id="code_1754295364967"><code>UPDATE TB_PRODUCT
SET STOCK = STOCK + 20
WHERE PCODE = 205;</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>3. TB_PRODETAIL 테이블에 INSERT 이벤트 발생시 TB_PRODUCT 테이블에 매번 자동으로 재고수량을 UPDATE하는 트리거- 상품이 입고(IN) -&gt; 해당 상품을 찾아서 재고수량 증가 UPDATE <br />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE&nbsp;TB_PRODUCT <br />&nbsp;&nbsp;&nbsp;&nbsp;SET&nbsp;STOCK&nbsp;=&nbsp;STOCK&nbsp;+&nbsp;20 <br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;PCODE&nbsp;=&nbsp;205; <br />- 상품이 출고(OUT) -&gt; 해당 상품을 찾아서 재고수량 감소 UPDATE <br />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE&nbsp;TB_PRODUCT <br />&nbsp;&nbsp;&nbsp;&nbsp;SET&nbsp;STOCK&nbsp;=&nbsp;STOCK&nbsp;-&nbsp;(INSERT된&nbsp;자료의&nbsp;AMOUNT) <br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;PCODE&nbsp;=&nbsp;(INSERT된&nbsp;자료의&nbsp;PCODE);</p>
<pre class="bash" id="code_1754295411783"><code>CREATE OR REPLACE TRIGGER TRG_02
AFTER INSERT
ON TB_PRODETAIL
FOR EACH ROW
BEGIN
    IF(:NEW.STATUS = 'IN')
        THEN UPDATE TB_PRODUCT
            SET STOCK = STOCK + :NEW.AMOUNT-- 실행할 문장
            WHERE PCODE = :NEW.PCODE;
    ELSE
        UPDATE TB_PRODUCT
        SET STOCK = STOCK - :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
    END IF;
END;
/</code></pre>
<p>&nbsp;</p>
<p>-&nbsp;210번&nbsp;상품이&nbsp;오늘날짜로&nbsp;7개&nbsp;입고</p>
<pre class="bash" id="code_1754295431702"><code>INSERT INTO TB_PRODETAIL
VALUES(SEQ_DECODE.NEXTVAL, 210, SYSDATE, 20, 'IN');</code></pre>
<p>&nbsp;</p>
<p>-&nbsp;205번&nbsp;상품이&nbsp;오늘날짜로&nbsp;5개&nbsp;출고</p>
<pre class="bash" id="code_1754295440590"><code>INSERT INTO TB_PRODETAIL
VALUES(SEQ_DECODE.NEXTVAL, 205, SYSDATE, 4, 'OUT');</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>4. 느낀점 &amp; 배운점</p>
<p>이번 수업에서는 PL/SQL의 구조와 기능을 익히며 데이터베이스 내에서 보다 유연하고 복잡한 로직을 구현할 수 있다는 점을 배웠다. PL/SQL은 변수 선언, 조건문, 반복문, 예외 처리 등을 지원하여 단순한 SQL을 넘어선 프로그래밍이 가능하다는 점에서 매우 실용적이었다.</p>
<p>특히 %TYPE과 %ROWTYPE을 이용해 테이블의 컬럼이나 행 전체를 참조해 변수를 선언하는 방식은 코드의 유지보수성과 안정성을 높이는 데 효과적이라고 느꼈다. 조건문과 반복문을 활용해 사용자 입력에 따라 다양한 처리 흐름을 구성할 수 있었고, 예외 처리 구문을 통해 실행 중 발생할 수 있는 오류에 유연하게 대응할 수 있다는 점도 인상 깊었다.</p>
<p>트리거를 통해 특정 테이블에서 INSERT, UPDATE, DELETE 등의 이벤트가 발생할 때 자동으로 로직을 실행할 수 있다는 것도 흥미로웠다. 예를 들어, 입출고 기록 테이블에 데이터가 추가될 때마다 상품 재고를 자동으로 갱신하도록 설정한 부분은 실무에서도 충분히 활용 가능할 것이라 생각된다.</p>
<p>전체적으로 이번 학습을 통해 단순 조회나 입력을 넘어서, 실제 데이터 흐름을 제어하고 자동화할 수 있는 능력을 기를 수 있었고, 데이터베이스를 보다 능동적으로 다룰 수 있는 자신감이 생겼다.</p>