# JPA

**카테고리**: Spring Boot

**작성일**: Wed, 7 Jan 2026 17:11:56 +0900

**원문 링크**: https://junsseok.tistory.com/75

---

<p style="text-align: center;">JPA</p>
<hr contenteditable="false" />
<p style="text-align: center;">JPA는 자바 객체와 관계형 데이터베이스(RDB)를 매핑하기 위한 표준 인터페이스입니다.<br />즉, SQL 중심의 개발에서 벗어나 객체 중심으로 데이터를 다룰 수 있게 해주는 기술이에요.</p>
<p style="text-align: center;">&nbsp;</p>
<p style="text-align: center;">JPA는 기술이 아니라 명세(Specification) 이며 실제 구현체로는 Hibernate, EclipseLink 등이 있습니다.</p>
<p style="text-align: center;"><br />Spring Boot에서는 기본적으로 Hibernate를 JPA 구현체로 사용합니다.</p>
<hr contenteditable="false" />
<h3 style="text-align: left;">SQL&nbsp;중심&nbsp;개발의&nbsp;문제점</h3>
<p style="text-align: left;">기존 <b>JDBC / MyBatis</b> 방식에서는 다음과 같은 문제가 발생합니다.<br />SQL을 직접 작성해야 한다 테이블 구조 변경 시 SQL 전체 수정 필요 객체&nbsp;&lt;-&gt;&nbsp;테이블&nbsp;간&nbsp;매핑&nbsp;코드&nbsp;반복 <br /><br />비즈니스 로직보다 DB 코드가 더 많아집니다.</p>
<pre class="bash" id="code_1767772169205"><code>ResultSet rs = pstmt.executeQuery();
while(rs.next()) {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
}</code></pre>
<p style="text-align: left;">-&gt; 객체지향과&nbsp;DB&nbsp;패러다임&nbsp;불일치&nbsp;문제</p>
<hr contenteditable="false" />
<h3 style="text-align: left;">JPA를&nbsp;사용하면?</h3>
<p>JPA를 사용하면 객체를 저장하듯이 DB에 저장할 수 있다.</p>
<p>&nbsp;</p>
<p>- SQL 자동 생성<br />- 객체 중심 설계 가능<br />- CRUD 코드 대폭 감소<br />-&nbsp;유지보수성&nbsp;향상</p>
<hr contenteditable="false" />
<h3>JPA 핵심 개념</h3>
<p><b>1. Entity</b></p>
<p>DB 테이블과 매칭되는 자바 클래스</p>
<pre class="bash" id="code_1767773114980"><code>@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}</code></pre>
<p>- @Entity : JPA가 관리하는 객체<br />- @Id : 기본 키<br />-&nbsp;@GeneratedValue&nbsp;:&nbsp;PK&nbsp;자동&nbsp;생성&nbsp;전략</p>
<p>&nbsp;</p>
<p><b>2.&nbsp;영속성&nbsp;컨텍스트&nbsp;(Persistence&nbsp;Context)</b></p>
<p>JPA의 핵심 개념</p>
<p>엔티티를 관리하는 논리적 공간</p>
<p>&nbsp;</p>
<p>엔티티 생명주기<br />(1)&nbsp;비영속&nbsp;(new) <br />(2)&nbsp;영속&nbsp;(managed) <br />(3)&nbsp;준영속&nbsp;(detached) <br />(4)&nbsp;삭제&nbsp;(removed)</p>
<pre class="bash" id="code_1767773182612"><code>User user = new User(); // 비영속
em.persist(user);      // 영속</code></pre>
<p>&nbsp;</p>
<p><b>3. 1차 캐시</b></p>
<p>영속성 컨텍스트 내부에는 1차 캐시가 존재한다.</p>
<pre class="bash" id="code_1767773204611"><code>em.find(User.class, 1L);
em.find(User.class, 1L); // DB 조회 X</code></pre>
<p>-&nbsp;같은&nbsp;트랜잭션&nbsp;내에서&nbsp;DB&nbsp;조회&nbsp;최소화 <br />-&nbsp;성능&nbsp;향상</p>
<p>&nbsp;</p>
<p><b> 4. 변경 감지 (Dirty Checking) </b></p>
<p>객체&nbsp;값을&nbsp;변경하면&nbsp;자동으로&nbsp;UPDATE&nbsp;SQL이&nbsp;실행됨</p>
<pre class="bash" id="code_1767773234916"><code>User user = em.find(User.class, 1L);
user.setName("변경된 이름");</code></pre>
<p>-&gt;&nbsp;em.update()&nbsp;같은&nbsp;메서드가&nbsp;없음 <br />-&gt;&nbsp;트랜잭션&nbsp;종료&nbsp;시점에&nbsp;변경&nbsp;사항&nbsp;자동&nbsp;반영</p>
<p>&nbsp;</p>
<p><b>5. 트랜잭션 쓰기 지연</b></p>
<pre class="bash" id="code_1767773266164"><code>em.persist(user1);
em.persist(user2);</code></pre>
<p>즉시&nbsp;INSERT&nbsp;실행하지&nbsp;않고&nbsp;SQL을&nbsp;모아두었다가&nbsp;커밋&nbsp;시점에&nbsp;한&nbsp;번에&nbsp;실행합니다.</p>
<hr contenteditable="false" />
<h3>연관관계 매핑</h3>
<p><b>단방향/양방향</b></p>
<pre class="bash" id="code_1767773309667"><code>@ManyToOne
@JoinColumn(name = "team_id")
private Team team;</code></pre>
<p>-&nbsp;연관관계의&nbsp;주인은&nbsp;외래키를&nbsp;관리하는&nbsp;쪽 <br />-&nbsp;mappedBy가&nbsp;있으면&nbsp;주인이&nbsp;아님 <br /><br />!!연관관계&nbsp;주인&nbsp;개념은&nbsp;JPA에서&nbsp;매우&nbsp;중요합니다!!</p>
<hr contenteditable="false" />
<h3>JPA vs MyBatis</h3>
<p><figure class="imageblock alignLeft"><span><img height="275" src="https://blog.kakaocdn.net/dn/rEuEU/dJMcaivcyas/W72HGxNnnKj8jKcw2tgsNk/img.png" width="582" /></span></figure>
</p>
<hr contenteditable="false" />
<h3>마무리</h3>
<p>JPA는 <br /><b>생산성을 높여주고, 객체지향적인 설계를 가능하게 하며, 유지보수에 강한 코드 작성</b>을 돕는 기술입니다.<br />하지만 내부 동작 원리를 이해하지 않으면 오히려 성능 이슈와 장애를 유발할 수 있습니다.<br />개념,&nbsp;내부&nbsp;동작,&nbsp;SQL&nbsp;이해&nbsp;이&nbsp;3가지를&nbsp;함께&nbsp;가져가는&nbsp;것이&nbsp;중요합니다!</p>