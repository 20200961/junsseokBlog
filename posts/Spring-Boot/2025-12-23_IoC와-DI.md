# IoC와 DI

**카테고리**: Spring Boot

**작성일**: Tue, 23 Dec 2025 17:30:24 +0900

**원문 링크**: https://junsseok.tistory.com/67

---

<p style="text-align: center;">IoC와 DI</p>
<hr contenteditable="false" />
<p style="text-align: center;">스프링을 공부하다 보면 IoC와 DI라는 용어를 계속 마주치게 됩니다.</p>
<p style="text-align: center;">처음엔 이게 뭔 소린가 싶었는데, 알고 보니 객체지향 프로그래밍의 핵심 개념이었어요.</p>
<hr contenteditable="false" />
<h3 style="text-align: left;">IoC (Inversion of Control)</h3>
<p>프로그램의 흐름을 개발자가 아닌 프레임워크가 제어한다는 뜻입니다.</p>
<p>전통적인 방식에서는 개발자가 직접 객체를 생성하고, 메서드를 호출하고, 프로그램의 흐름을 관리했었습니다.</p>
<p>그런데 IoC에서는 이 제어권이 역전되요. 프레임워크가 프로그램의 흐름을 주도하고,</p>
<p>개발자가 작성한 코드를 필요할 때 호출하는 방식입니다다.</p>
<pre class="bash" id="code_1766477354264"><code>public class UserService {
    private UserRepository repository = new UserRepository();
    
    public void saveUser(User user) {
        repository.save(user);
    }
}</code></pre>
<p>&nbsp;</p>
<p>-&gt; 여기서는 UserService가 직접 UserRepository 객체를 생성한다. 모든 제어권이 UserService에 있는 셈입니다.</p>
<hr contenteditable="false" />
<h3>DI (Dependency Injection) - 의존성 주입</h3>
<p>DI는 IoC를 구현하는 구체적인 방법 중 하나입니다. 객체가 필요로 하는 의존성을 외부에서 주입받는 방식이에요.</p>
<pre class="bash" id="code_1766477877088"><code>// DI를 적용한 방식
public class UserService {
    private final UserRepository repository;
    
    // 생성자를 통한 의존성 주입
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
    
    public void saveUser(User user) {
        repository.save(user);
    }
}</code></pre>
<p>-&gt; UserService는 UserRepository를 직접 생성하지 않습니다. 누군가 외부에서 만들어서 넣어주는 걸 받아 쓰기만 해요.</p>
<hr contenteditable="false" />
<h3>DI의 장점</h3>
<ol>
<li><b>결합도가 낮아진다<br /></b>UserService는 이제 UserRepository의 구체적인 구현을 몰라도 된다. 인터페이스만 알면 충분합니다.</li>
<li><b>테스트가 쉬워진다<br /></b>테스트할 때 가짜 객체(Mock)를 주입해서 테스트할 수 있습니다.</li>
<li><b>코드 재사용성이 높아진다<br /></b>같은 클래스를 여러 상황에서 다른 의존성과 함께 사용할 수 있습니다.</li>
</ol>
<hr contenteditable="false" />
<h3>DI의 3가지 방식</h3>
<pre class="bash" id="code_1766477963760"><code>// 1. 생성자 주입
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// 2. Setter 주입
public class UserService {
    private UserRepository repository;
    
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
}

// 3. 필드 주입
public class UserService {
    @Autowired
    private UserRepository repository;
}</code></pre>
<p>&nbsp;</p>
<p>-&gt; 객체가 생성될 때 필요한 의존성을 모두 받기 때문에 불완전한 상태로 존재할 일이 없고,</p>
<p>final 키워드를 사용할 수 있어서 불변성도 보장됩니다.</p>
<hr contenteditable="false" />
<h3>스프링에서의 IoC와 DI</h3>
<p>스프링 프레임워크는 IoC 컨테이너를 제공합니다. 이 컨테이너가 객체의 생명주기를 관리하고, 의존성을 주입해줘요.</p>
<pre class="bash" id="code_1766478010479"><code>@Service
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}</code></pre>
<p>&nbsp;</p>
<p>-&gt; @Service, @Repository 같은 어노테이션을 붙이면 스프링이 해당 클래스의 객체를 생성해서</p>
<p>컨테이너에 등록해주고 필요한 곳에 자동으로 주입해줍니다.</p>
<p>&nbsp;</p>
<hr contenteditable="false" />
<h2 style="text-align: center;">면접한줄요약</h2>
<p style="text-align: center;">IoC은 프로그램 제어권이 개발자에서 프레임워크로 넘어가는 것이고</p>
<p style="text-align: center;">DI은 IoC를 구현하는 방법으로, 필요한 객체를 외부에서 주입받는 것입니다.</p>
<p style="text-align: center;">이 둘을 활용하면 결합도는 낮추고 유연성은 높일 수 있습니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>